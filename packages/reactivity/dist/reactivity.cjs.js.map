{"version":3,"file":"reactivity.cjs.js","sources":["../src/effect.ts","../../runtime-core/src/watch.ts","../src/reactive.ts","../../runtime-core/src/renderer.ts","../src/computed.ts","../src/ref.ts"],"sourcesContent":["\r\nimport type { Dep } from './dep'\r\n//清除函数\r\nfunction cleanup(effectFn){\r\n    for(let i = 0 ; i < effectFn.deps.length;i++){\r\n        const deps = effectFn.deps[i]\r\n        deps.delete(effectFn)\r\n    }\r\n    effectFn.deps.length = 0;\r\n}\r\nexport const ITERATE_KEY = Symbol()\r\n//这个bucket就是来存副作用函数的\r\nconst bucket = new WeakMap<any,Map<string,Set<Function>>>();\r\n//用一个全局变量activeEffect来存储被注册的副作用函数\r\nlet activeEffect:any\r\n//这个栈：当发生effect嵌套时，会出现第二个(子effect)把第一个（父effect）的activeEffect给覆盖(因为同时activeEffect的值只有一个)，所以需要一个栈来存储正在执行的副作用函数，副作用函数执行完毕就给弹出\r\nconst effectStack:Array<any> = []\r\n// class RectiveEffect<T = any>{\r\n//     //因为set的时候改变值会触发新的set，所以为了避免死循环，需要一个字段来识别是否执行这个副作用函数,true就是这个副作用函数在执行，false就是没有执行就要触发。\r\n//     //因为在一开始创建effect的时候肯定是接下来在触发的（这就是业务要求)所以初始为true,接下来执行完就需要手动设置为false\r\n//     active=true\r\n//     //这个deps就是用来存放副作用函数的\r\n//     deps:Dep[] = []\r\n// }\r\n//effect函数\r\nexport function effect(fn:() => any,options:Object = {}){ \r\n    const effectFn = () => {\r\n        cleanup(effectFn)\r\n        activeEffect = effectFn\r\n        effectStack.push(effectFn)\r\n        const result = fn()\r\n        effectStack.pop()\r\n        //把栈顶函数拿出来给active,就是为了解决嵌套\r\n        activeEffect = effectStack[effectStack.length - 1]   \r\n        return result\r\n    }\r\n    //源码里的effectFn是一个class类\r\n    effectFn.deps = []\r\n    effectFn.options = options\r\n    if(!options.lazy){\r\n        effectFn()\r\n    }\r\n    return effectFn\r\n}\r\n//track ,目的是把当前的activeEffect存储到target和key的依赖集合中\r\nexport const track = <T>(target:T,key:string |symbol):void => {\r\n    //这里的判断是，当副作用函数effect已经执行完，接下来系统中某个地方改变了代理值，effect取出重新执行时，依然会触发代理的get（这时候就没有必要再注册一边了）。这个时候是没有active的，所以用这个来让其避免重复注册\r\n    if(!activeEffect) return\r\n    let depsMap = bucket.get(target)\r\n    if(!depsMap) bucket.set(target,(depsMap = new Map()));\r\n    let deps = depsMap.get(key)\r\n    if(!deps) depsMap.set(key,(deps = new Set()))\r\n    deps.add(activeEffect)\r\n    activeEffect.deps.push(deps)\r\n}\r\n//trigger,目的是把当前target和key的依赖集合中的函数取出并执行一遍\r\nexport const trigger = <T>(target:T,key:string,type:string |symbol,newVal?:any):void => {\r\n    let depsMap = bucket.get(target)\r\n    if(!depsMap) return\r\n    let deps = depsMap.get(key)\r\n    const effectsToRun = new Set()\r\n    if(type == 'ADD') {\r\n        //把跟ITERATE绑定的（forin这种情况）拿出执行\r\n        const iterateEffects = depsMap.get(ITERATE_KEY)\r\n        iterateEffects && iterateEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }   \r\n    //如果是数组。那么需要额外处理\r\n    if(type === 'ADD' && Array.isArray(target)){\r\n        const lengthEffects = depsMap.get('length')\r\n        lengthEffects && lengthEffects.forEach(effectFn => {\r\n            if(effectFn !== activeEffect){\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n    //如果改变length，就需要把大于等于length的值拿出来遍历\r\n    if(Array.isArray(target) && key === 'length'){\r\n        depsMap.forEach((effects,key) => {\r\n           if(key >= newVal){\r\n            effects.forEach(effectFn => {\r\n                if(effectFn !== activeEffect){\r\n                    effectsToRun.add(effectFn)\r\n                }\r\n            })\r\n           }\r\n        })\r\n    }\r\n    deps && deps.forEach(effect => {\r\n        if(effect != activeEffect) {\r\n            effectsToRun.add(effect)\r\n        }\r\n    })\r\n    effectsToRun.forEach(effectFn => {\r\n        if(effectFn.options.scheduler){\r\n            effectFn.options.scheduler(effectFn)\r\n        }else{\r\n            effectFn()\r\n        }\r\n    })\r\n}\r\n","import { effect } from \"packages/reactivity/index\";\r\n\r\nexport function watch(source:any,cb:Function,options:{immediate:boolean,flush?:string} = {immediate:false}){\r\n    //定义一个getter来接一个函数，如果函数的\r\n    let getter:Function\r\n    if(typeof source === 'function'){\r\n        getter = source\r\n    }else{\r\n        getter = () => traverse(source)\r\n    }\r\n    //闭包保存此时的新值和旧值\r\n    let newValue:any = null,oldValue:any = null\r\n    //定义一个函数寄存外部传来的fn\r\n    let cleanup:Function\r\n    function onInvalidate(fn:Function){\r\n        cleanup = fn\r\n    }\r\n    const job = () =>{\r\n        //执行副作用函数拿到新值   \r\n        newValue = effectFn()\r\n        //执行watch传入的函数\r\n        if(cleanup) cleanup()\r\n        cb(newValue,oldValue,onInvalidate)\r\n        //把旧值更新\r\n        oldValue = newValue\r\n    }\r\n    const effectFn = effect(() => getter(),{\r\n        lazy:true,\r\n        scheduler:() => {\r\n            if(options.flush == 'post'){\r\n                const p = Promise.resolve()\r\n                p.then(() => job())\r\n            }else{\r\n                job()\r\n            }\r\n        }\r\n    })\r\n    //第一次执行拿到添加响应式依赖\r\n    if(options.immediate){\r\n        job()\r\n    }else{\r\n        oldValue = effectFn()\r\n    }\r\n}\r\nfunction traverse<T>(value:T,seen:Set<any> = new Set()):T|void{\r\n    if(typeof value != 'object' || value == null || seen.has(value)) return\r\n    seen.add(value)\r\n    for (const key in value as Object) {\r\n        traverse(value[key as keyof Object],seen)\r\n    }\r\n    return value\r\n}","import { track,trigger ,ITERATE_KEY} from \"./effect\";\r\n//重写includes,indexof函数，因为原来的这几个函数的this指向是响应式对象\r\nconst originMethod = Array.prototype.includes\r\nconst arrayInstrumentations = {}\r\nconst methods = ['include','indexOf','lastIndexOf']\r\nmethods.forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n    arrayInstrumentations[method] = function(...args){\r\n        let res = originMethod.apply(this,args)\r\n        if(res === false || res === -1){\r\n            res = originMethod.apply(this.raw,args)\r\n        }\r\n        return res\r\n    }\r\n})\r\n//一个标记变量，代表是否进行跟踪。默认为true,代表允许跟踪\r\nlet shouldTrack:Boolean = true\r\nlet changeLengthmethods = ['push']\r\nchangeLengthmethods.forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n})\r\nexport function createReactive(data:Object,isShallow = false,isReadonly = false){ \r\n    return new Proxy(data, {\r\n        get(target, key,receiver) {   \r\n            if(key === 'raw') return target\r\n            if(Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) return Reflect.get(arrayInstrumentations,key,receiver)\r\n            if(!isReadonly && typeof key !== 'symbol') track(target,key)    \r\n            //Reflect对象，后面的receiver是对象本身，类似this\r\n            const res =  Reflect.get(target,key,receiver); \r\n            if(typeof res == 'object' && res!=null && !isShallow){\r\n                return isReadonly ? readonly(res) : reactive(res)\r\n            }\r\n            return res // 返回属性值\r\n        },\r\n        set(target, key, newVal,receiver) {\r\n            //判断是否只读\r\n            if(isReadonly){\r\n                console.warn(`属性${key} 是只读的`)\r\n                return true\r\n            }\r\n            //先获取旧值\r\n            const oldVal = target[key]\r\n            //属性不存在就添加新属性，否则就是设置已有已有属性\r\n            const type = Array.isArray(target) ? Number(key) < target.length ? 'SET':'ADD'  : Object.prototype.hasOwnProperty.call(target,key) ? 'SET':'ADD'\r\n            //设置属性值\r\n            const res = Reflect.set(target, key, newVal, receiver)  // 设置新值\r\n            // 触发所有副作用函数\r\n            if(target === receiver.raw){\r\n                if(oldVal != newVal && (oldVal === oldVal || newVal === newVal)) trigger(target,key,type,newVal)\r\n            }\r\n            return true;\r\n        },\r\n        //has来对in操作符来拦截\r\n        has(target,key){\r\n            track(target,key)\r\n            return Reflect.get(target,key);\r\n        },\r\n        //拦截forin\r\n        ownKeys(target) {\r\n            // 将副作用函数与 ITERATE_KEY 关联,拦截for...in\r\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\r\n            return Reflect.ownKeys(target)\r\n        },\r\n        //拦截删除\r\n        deleteProperty(target,key){\r\n            if(isReadonly){\r\n                console.warn(`属性${key} 是只读的`)\r\n                return true\r\n            }\r\n            const hadKey = Object.prototype.hasOwnProperty.call(target,key)\r\n            const res = Reflect.deleteProperty(target, key)\r\n            if (res && hadKey) {\r\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\r\n                trigger(target, key, 'DELETE')\r\n            }\r\n            return res\r\n        }\r\n    });\r\n}\r\n//这个值用来记录Obj是否已经创建过代理对象\r\nconst reactiveMap = new Map()\r\n//建立深响应\r\nexport function reactive(data:Object){\r\n    //如果传入的对象曾经创建过响应式对象，就把曾经创建的对象返回出去\r\n    const proxyObj = reactiveMap.get(data)\r\n    if(proxyObj) return proxyObj\r\n    const nowObj = createReactive(data)\r\n    //存起来避免重复创建\r\n    reactiveMap.set(data,nowObj)\r\n    return nowObj\r\n}\r\n//建立浅响应\r\nexport function shallowReactive(data:Object){\r\n    return createReactive(data,true)\r\n}\r\nexport function readonly(data:Object){\r\n    return createReactive(data,false,true)\r\n}\r\nexport function shallowReadonly(data:Object){\r\n    return createReactive(data,true,true)\r\n}","interface Options {\r\n    createElement: (vnode:VNode) => HTMLElement\r\n    insert:(el:HTMLElement,parents:HTMLElement) => void\r\n    setElementText:(el:HTMLElement,text:string) => void\r\n    patchProps:(el:HTMLElement,key:string,prevValue:string,nextValue:string) => void \r\n}\r\ninterface Render {\r\n    render: (vnode:VNode,container:VHTMLElement) => void\r\n}\r\nexport function createRenderer(options:Options):Render{\r\n    const {createElement,insert,setElementText} = options\r\n    function mountElement(vnode:VNode,container:VHTMLElement):void{\r\n        const el = createElement(vnode)\r\n        if(vnode.props){\r\n            for(const key in vnode.props){\r\n                el.setAttribute(key,vnode.props[key])\r\n            }\r\n        }\r\n        //处理子类节点\r\n        if(typeof vnode.children =='string'){\r\n            setElementText(el,vnode.children)\r\n        }else if(Array.isArray(vnode.children)){\r\n            vnode.children.forEach(child => patch(null,child,el as VHTMLElement))\r\n        }\r\n        insert(el, container)\r\n    }\r\n    function patch(n1:VNode | undefined | null,n2:VNode,container:VHTMLElement):void{\r\n        if(!n1){\r\n            mountElement(n2,container)\r\n        }else{\r\n\r\n        }\r\n\r\n    }\r\n    function render(vnode:VNode,container:VHTMLElement):void{\r\n        if(vnode){\r\n            patch(container._vnode,vnode,container)\r\n        }else{\r\n            if(container._vnode){\r\n                //卸载载旧节点\r\n                container.innerHTML = ''\r\n            }\r\n        }\r\n        container._vnode = vnode\r\n    }\r\n    return {\r\n        render\r\n    }\r\n}\r\n//写成这样的目的是脱离完全依赖浏览器的掌控，让节点的操作是可人为定义的\r\nexport const renderer = createRenderer({\r\n    createElement:(vnode:VNode) => {\r\n        return document.createElement(vnode.type)\r\n    },\r\n    insert:(el:HTMLElement,container:HTMLElement) => {\r\n        container.appendChild(el)   \r\n    },\r\n    setElementText:(el:HTMLElement,text:string) => {\r\n        el.textContent = text\r\n    },\r\n    patchProps:(el:HTMLElement,key:string,prevValue:string,nextValue:string) => {\r\n        if(shouldSetAsProps(el,key)){\r\n            const type = typeof el[key]\r\n            if(type === 'boolean' && nextValue === ''){\r\n                el[key] = true\r\n            }else{\r\n                el[key] = nextValue\r\n            }\r\n        }else{\r\n            el.setAttribute(key,nextValue)\r\n        }\r\n    }\r\n})","import { effect, track, trigger } from \"./effect\"\r\n\r\nexport function computed(getter){\r\n    let value\r\n    //这个dirty是配合调度器用的\r\n    let dirty = true\r\n    const effectFn = effect(getter,{\r\n        lazy:true,\r\n        scheduler:()=>{\r\n            if(!dirty){\r\n                //调度器执行就证明值有改变然后需要下次get的时候重新调用一下了\r\n                dirty = true\r\n                trigger(obj,'value')\r\n            }\r\n        }\r\n    })\r\n    const obj = {\r\n        get value(){\r\n            if(dirty){\r\n                //执行这个activeEffect函数就已经设为当前的effectFn了\r\n                //然后其内部再有其他的响应式对象，执行时会嵌套触发新的响应式对象读取，又给他们（内部的所有响应式对象）加上了这个active\r\n                value = effectFn()\r\n                dirty = false\r\n            }\r\n            //紧接着跟track，就把computed的effectFn收集了\r\n            track(obj,'value')\r\n            //实际上是把computed的value返回了\r\n            return value\r\n        }\r\n    }\r\n    return obj\r\n}\r\n","import { reactive } from \"./reactive\"\r\nexport function ref(value:any){\r\n    const wrapper = {\r\n        value:value\r\n    }\r\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\r\n    return reactive(wrapper)\r\n}\r\nexport function toRef(obj:Object,key:string){\r\n    const wrapper = {\r\n        get value(){\r\n            return obj[key]\r\n        },\r\n        set value(newVal){\r\n            obj[key] = newVal\r\n        }\r\n    }\r\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\r\n    return wrapper\r\n}\r\nexport function toRefs(obj:Object){\r\n    const ret = {}\r\n    for(const key in obj){\r\n        ret[key] = toRef(obj,key)\r\n    }\r\n    return ret\r\n}\r\nexport function proxyRefs(target){\r\n    return new Proxy(target,{\r\n        get(target,key,receiver){\r\n            const value = Reflect.get(target,key,receiver)\r\n            //是ref就用这个来返回.value后的值，不是ref就不返回\r\n            return value.__v_isRef ? value.value : value\r\n        }\r\n    })\r\n}"],"names":["ITERATE_KEY","Symbol","bucket","WeakMap","activeEffect","effectStack","effect","fn","options","effectFn","i","deps","length","delete","cleanup","push","result","pop","lazy","track","target","key","depsMap","get","set","Map","Set","add","trigger","type","newVal","effectsToRun","iterateEffects","forEach","Array","isArray","lengthEffects","effects","scheduler","traverse","value","seen","has","arrayInstrumentations","createReactive","data","isShallow","isReadonly","Proxy","receiver","hasOwnProperty","Reflect","res","readonly","reactive","console","warn","oldVal","Number","Object","prototype","call","raw","ownKeys","deleteProperty","hadKey","method","originMethod","args","apply","this","reactiveMap","proxyObj","nowObj","renderer","createElement","insert","setElementText","patch","n1","n2","container","vnode","el","props","setAttribute","children","child","mountElement","render","_vnode","innerHTML","createRenderer","document","appendChild","text","textContent","patchProps","prevValue","nextValue","shouldSetAsProps","getter","dirty","obj","wrapper","defineProperty","source","cb","immediate","newValue","oldValue","onInvalidate","job","flush","Promise","resolve","then"],"mappings":"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"}