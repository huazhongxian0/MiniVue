{"version":3,"file":"reactivity.iife.js","sources":["../src/effect.ts","../../runtime-core/src/watch.ts","../src/reactive.ts","../../runtime-core/src/queue.ts","../../runtime-core/src/renderer.ts","../src/computed.ts","../src/ref.ts"],"sourcesContent":["\nimport type { Dep } from './dep'\n//清除函数\nfunction cleanup(effectFn){\n    for(let i = 0 ; i < effectFn.deps.length;i++){\n        const deps = effectFn.deps[i]\n        deps.delete(effectFn)\n    }\n    effectFn.deps.length = 0;\n}\nexport const ITERATE_KEY = Symbol()\n//这个bucket就是来存副作用函数的\nconst bucket = new WeakMap<any,Map<string,Set<Function>>>();\n//用一个全局变量activeEffect来存储被注册的副作用函数\nlet activeEffect:any\n//这个栈：当发生effect嵌套时，会出现第二个(子effect)把第一个（父effect）的activeEffect给覆盖(因为同时activeEffect的值只有一个)，所以需要一个栈来存储正在执行的副作用函数，副作用函数执行完毕就给弹出\nconst effectStack:Array<any> = []\n// class RectiveEffect<T = any>{\n//     //因为set的时候改变值会触发新的set，所以为了避免死循环，需要一个字段来识别是否执行这个副作用函数,true就是这个副作用函数在执行，false就是没有执行就要触发。\n//     //因为在一开始创建effect的时候肯定是接下来在触发的（这就是业务要求)所以初始为true,接下来执行完就需要手动设置为false\n//     active=true\n//     //这个deps就是用来存放副作用函数的\n//     deps:Dep[] = []\n// }\n//effect函数\nexport function effect(fn:() => any,options:Object = {}){ \n    const effectFn = () => {\n        cleanup(effectFn)\n        activeEffect = effectFn\n        effectStack.push(effectFn)\n        const result = fn()\n        effectStack.pop()\n        //把栈顶函数拿出来给active,就是为了解决嵌套\n        activeEffect = effectStack[effectStack.length - 1]   \n        return result\n    }\n    //源码里的effectFn是一个class类\n    effectFn.deps = []\n    effectFn.options = options\n    if(!options.lazy){\n        effectFn()\n    }\n    return effectFn\n}\n//track ,目的是把当前的activeEffect存储到target和key的依赖集合中\nexport const track = <T>(target:T,key:string |symbol):void => {\n    //这里的判断是，当副作用函数effect已经执行完，接下来系统中某个地方改变了代理值，effect取出重新执行时，依然会触发代理的get（这时候就没有必要再注册一边了）。这个时候是没有active的，所以用这个来让其避免重复注册\n    if(!activeEffect) return\n    let depsMap = bucket.get(target)\n    if(!depsMap) bucket.set(target,(depsMap = new Map()));\n    let deps = depsMap.get(key)\n    if(!deps) depsMap.set(key,(deps = new Set()))\n    deps.add(activeEffect)\n    activeEffect.deps.push(deps)\n}\n//trigger,目的是把当前target和key的依赖集合中的函数取出并执行一遍\nexport const trigger = <T>(target:T,key:string,type:string |symbol,newVal?:any):void => {\n    let depsMap = bucket.get(target)\n    if(!depsMap) return\n    let deps = depsMap.get(key)\n    const effectsToRun = new Set()\n    if(type == 'ADD') {\n        //把跟ITERATE绑定的（forin这种情况）拿出执行\n        const iterateEffects = depsMap.get(ITERATE_KEY)\n        iterateEffects && iterateEffects.forEach(effectFn => {\n            if (effectFn !== activeEffect) {\n                effectsToRun.add(effectFn)\n            }\n        })\n    }   \n    //如果是数组。那么需要额外处理\n    if(type === 'ADD' && Array.isArray(target)){\n        const lengthEffects = depsMap.get('length')\n        lengthEffects && lengthEffects.forEach(effectFn => {\n            if(effectFn !== activeEffect){\n                effectsToRun.add(effectFn)\n            }\n        })\n    }\n    //如果改变length，就需要把大于等于length的值拿出来遍历\n    if(Array.isArray(target) && key === 'length'){\n        depsMap.forEach((effects,key) => {\n           if(key >= newVal){\n            effects.forEach(effectFn => {\n                if(effectFn !== activeEffect){\n                    effectsToRun.add(effectFn)\n                }\n            })\n           }\n        })\n    }\n    deps && deps.forEach(effect => {\n        if(effect != activeEffect) {\n            effectsToRun.add(effect)\n        }\n    })\n    effectsToRun.forEach(effectFn => {\n        if(effectFn.options.scheduler){\n            effectFn.options.scheduler(effectFn)\n        }else{\n            effectFn()\n        }\n    })\n}\n","import { effect } from \"packages/reactivity/index\";\n\nexport function watch(source:any,cb:Function,options:{immediate:boolean,flush?:string} = {immediate:false}){\n    //定义一个getter来接一个函数，如果函数的\n    let getter:Function\n    if(typeof source === 'function'){\n        getter = source\n    }else{\n        getter = () => traverse(source)\n    }\n    //闭包保存此时的新值和旧值\n    let newValue:any = null,oldValue:any = null\n    //定义一个函数寄存外部传来的fn\n    let cleanup:Function\n    function onInvalidate(fn:Function){\n        cleanup = fn\n    }\n    const job = () => {\n        //执行副作用函数拿到新值   \n        newValue = effectFn()\n        //执行watch传入的函数\n        if(cleanup) cleanup()\n        cb(newValue,oldValue,onInvalidate)\n        //把旧值更新\n        console.log('oldSet了为',oldValue.name);\n        oldValue = newValue\n    }\n    const effectFn = effect(() => getter(),{\n        lazy:true,\n        scheduler:() => {\n            if(options.flush == 'post'){\n                const p = Promise.resolve()\n                p.then(() => job())\n            }else{\n                job()\n            }\n        }\n    })\n    //第一次执行拿到添加响应式依赖\n    if(options.immediate){\n        job()\n    }else{\n        oldValue = effectFn()\n    }\n}\nfunction traverse<T>(value:T,seen:Set<any> = new Set()):T|void{\n    if(typeof value != 'object' || value == null || seen.has(value)) return\n    seen.add(value)\n    for (const key in value as Object) {\n        traverse(value[key as keyof Object],seen)\n    }\n    return value\n}","import { track,trigger ,ITERATE_KEY} from \"./effect\";\n//重写includes,indexof函数，因为原来的这几个函数的this指向是响应式对象\nconst originMethod = Array.prototype.includes\nconst arrayInstrumentations = {}\nconst methods = ['include','indexOf','lastIndexOf']\nmethods.forEach(method => {\n    const originMethod = Array.prototype[method]\n    arrayInstrumentations[method] = function(...args){\n        let res = originMethod.apply(this,args)\n        if(res === false || res === -1){\n            res = originMethod.apply(this.raw,args)\n        }\n        return res\n    }\n})\n//一个标记变量，代表是否进行跟踪。默认为true,代表允许跟踪\nlet shouldTrack:Boolean = true\nlet changeLengthmethods = ['push']\nchangeLengthmethods.forEach(method => {\n    const originMethod = Array.prototype[method]\n})\nexport function createReactive(data:Object,isShallow = false,isReadonly = false){ \n    return new Proxy(data, {\n        get(target, key,receiver) {   \n            if(key === 'raw') return target\n            if(Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) return Reflect.get(arrayInstrumentations,key,receiver)\n            if(!isReadonly && typeof key !== 'symbol') track(target,key)    \n            //Reflect对象，后面的receiver是对象本身，类似this\n            const res =  Reflect.get(target,key,receiver); \n            if(typeof res == 'object' && res!=null && !isShallow){\n                return isReadonly ? readonly(res) : reactive(res)\n            }\n            return res // 返回属性值\n        },\n        set(target, key, newVal,receiver) {\n            //判断是否只读\n            if(isReadonly){\n                console.warn(`属性${key} 是只读的`)\n                return true\n            }\n            //先获取旧值\n            const oldVal = target[key]\n            //属性不存在就添加新属性，否则就是设置已有已有属性\n            const type = Array.isArray(target) ? Number(key) < target.length ? 'SET':'ADD'  : Object.prototype.hasOwnProperty.call(target,key) ? 'SET':'ADD'\n            //设置属性值\n            const res = Reflect.set(target, key, newVal, receiver)  // 设置新值\n            // 触发所有副作用函数\n            if(target === receiver.raw){\n                if(oldVal != newVal && (oldVal === oldVal || newVal === newVal)) trigger(target,key,type,newVal)\n            }\n            return true;\n        },\n        //has来对in操作符来拦截\n        has(target,key){\n            track(target,key)\n            return Reflect.get(target,key);\n        },\n        //拦截forin\n        ownKeys(target) {\n            // 将副作用函数与 ITERATE_KEY 关联,拦截for...in\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\n            return Reflect.ownKeys(target)\n        },\n        //拦截删除\n        deleteProperty(target,key){\n            if(isReadonly){\n                console.warn(`属性${key} 是只读的`)\n                return true\n            }\n            const hadKey = Object.prototype.hasOwnProperty.call(target,key)\n            const res = Reflect.deleteProperty(target, key)\n            if (res && hadKey) {\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\n                trigger(target, key, 'DELETE')\n            }\n            return res\n        }\n    });\n}\n//这个值用来记录Obj是否已经创建过代理对象\nconst reactiveMap = new Map()\n//建立深响应\nexport function reactive(data:Object){\n    //如果传入的对象曾经创建过响应式对象，就把曾经创建的对象返回出去\n    const proxyObj = reactiveMap.get(data)\n    if(proxyObj) return proxyObj\n    const nowObj = createReactive(data)\n    //存起来避免重复创建\n    reactiveMap.set(data,nowObj)\n    return nowObj\n}\n//建立浅响应\nexport function shallowReactive(data:Object){\n    return createReactive(data,true)\n}\nexport function readonly(data:Object){\n    return createReactive(data,false,true)\n}\nexport function shallowReadonly(data:Object){\n    return createReactive(data,true,true)\n}","const queue:Set<Function> = new Set()\nlet isFlushing = false\nconst p = Promise.resolve()\nexport function queueJob(job:Function){\n    queue.add(job)\n    if(!isFlushing){\n        isFlushing = true\n        p.then(() => {\n            try {\n                queue.forEach(job => job())\n            } catch (error) {\n                console.error(error);\n            } finally {\n                isFlushing = false\n                queue.clear = 0\n            }\n        })\n    }\n}","import {effect, reactive, shallowReactive} from '../../reactivity/index'\nimport {queueJob} from './queue'\ninterface Options {\n    createElement: (vnode:VNode) => VHTMLElement\n    insert:(el:HTMLElement,parents:HTMLElement) => void\n    setElementText:(el:HTMLElement,text:string) => void\n    patchProps:(el:HTMLElement,key:string,prevValue:string,nextValue:string) => void \n    createText: (text:string) => Text\n    setText: (el:VHTMLElement,text:string) => void\n}\ninterface Render {\n    render: (vnode:VNode,container:VHTMLElement) => void\n}\nfunction shouldSetAsProps(el:HTMLElement,key:string):Boolean{\n    return key === 'form' && el.tagName === 'INPUT' ? false : key in el\n}\nexport function createRenderer(options:Options):Render{\n    const {createElement,insert,setElementText,patchProps,createText,setText} = options\n    //设置props\n    function setProps(el:HTMLElement,vnode:VNode):void{\n        if(vnode.props) {\n            for(const key in vnode.props){\n                patchProps(el,key,null,vnode.props[key])\n            }\n        }\n    }\n    function diff(oldChildren:VNode[],newChildren:VNode[],el:VHTMLElement){\n         //其实这里就是diff\n                // 1.无优化，假diff\n                const oldlen = oldChildren.length\n                const newlen = newChildren.length\n                const commonlen = Math.min(oldlen,newlen)\n                for(let i = 0;i < commonlen;i++){\n                    patch(oldChildren[i],newChildren[i],el)\n                }\n                if(newlen > oldlen){\n                    for(let i = commonlen;i < newlen;i++){\n                        patch(null,newChildren[i],el)\n                    }\n                }else if(newlen < oldlen){\n                    for(let i = commonlen;i < oldlen;i++){\n                        unmount(oldChildren[i])\n                    }\n                }\n                // 2.快速diff（好tm难啊～～～）\n                // const oldChildren = n1.children\n                // const newChildren = n2.children\n                // for(let i = 0;i < newChildren.length;i++){\n                //     const newChild = newChildren[i]\n                //     for(let j = 0;j < oldChildren.length;j++){\n                //         const oldChild = oldChildren[j]\n                //         if(oldChild.key === newChild.key){\n                //             patch(oldChild,newChild,el)\n                //             break\n                //         }\n                //     }\n                // }\n    }   \n    function mountElement(vnode:VNode,container:VHTMLElement):void{\n        const el = vnode.el = createElement(vnode)\n        setProps(el,vnode)\n        //处理子类节点\n        if(typeof vnode.children =='string'){\n            setElementText(el,vnode.children)\n        }else if(Array.isArray(vnode.children)){\n            vnode.children.forEach(child => patch(null,child,el as VHTMLElement))\n        }\n        if(vnode.props){\n            for(const key in vnode.props){\n                patchProps(el,key,null,vnode.props[key])\n            }\n        }\n        insert(el, container)\n    }\n    function patchChildren(n1:VNode,n2:VNode,el:VHTMLElement):void{\n        if(typeof n2.children === 'string'){\n            if(Array.isArray(n1.children)){\n                n1.children.forEach(child => unmount(child))\n            }\n            setElementText(el,n2.children)\n        } else if(Array.isArray(n2.children)){\n            if(Array.isArray(n1.children)){\n               diff(n1.children,n2.children,el)\n            }else{\n                setElementText(el,'')\n                n2.children.forEach(child => patch(null,child,el))\n            }\n            \n        } else {\n            if(Array.isArray(n1.children)){\n                n1.children.forEach(child => unmount(child))\n            }else if(typeof n1.children === 'string'){\n                setElementText(el,'')\n            }\n        }\n    }\n    function patchElement(n1:VNode,n2:VNode):void{\n        const el = n2.el = n1.el\n        const oldProps = n1.props\n        const newProps = n2.props\n        for(const key in newProps){\n            if(oldProps?.[key] !== newProps?.[key]){\n                patchProps(el,key,oldProps?.[key],newProps?.[key])\n            }\n        }\n        patchChildren(n1,n2,el)\n    }\n    function resolveProps(options:Record<string,any> | undefined = {},propsData:Record<string,any>  | undefined):[Record<string,any>,Record<string,any>]{\n        const props:Record<string,any> = {}\n        const attrs:Record<string,any> = {}\n        for(const key in propsData){\n            if(key in options){\n                props[key] = propsData[key]\n            } else {\n                attrs[key] = propsData[key]\n            }\n        }\n        return [props,attrs]\n    }\n    function mountComponent(n2:VNode,container:VHTMLElement,anchor:VHTMLElement):void{\n        const componentOptions = n2.type as ComponentType\n        const {setup,render,data,beforeCreate,created,beforeMount,mounted,beforeUpdate,updated, props:propsOption} = componentOptions\n        beforeCreate && beforeCreate()\n        //这里其实返回了一个虚拟dom\n        const state = reactive(data?.() || {})\n        const [props,attrs] = resolveProps(propsOption,n2.props)\n        const instance:ComponentType = {\n            state,\n            props: shallowReactive(props),\n            isMounted:false,\n            subTree:null\n        }\n\n        const setupContext = {attrs}\n\n\n        n2.component = instance as ComponentType\n        const setupResult = setup(shallowReactive(instance.props),setupContext)\n        const renderContext = new Proxy(instance,{\n            get(t,k,r){\n                const { state,props } = t\n                if(state && k in state){\n                    return state[k]\n                } else if(props && k in props){\n                    return props[k]\n                } else {\n                    console.error('不存在')\n                }\n            },\n            set (t,k,v,r){\n                const {state,props} = t\n                if(state && k in state){\n                    state[k] = v\n                } else if(props && k in props){\n                    console.warn('props 是只读的')\n                } else {\n                    console.error('不存在')\n                }\n                return true\n            }\n        })\n        created && created.call(renderContext)\n        effect(() => {\n            const subTree = render?.call(renderContext,state)\n            if(!instance.isMounted){\n                beforeMount && beforeMount.call(renderContext)\n                patch(null,subTree as VNode,container,anchor)\n                instance.isMounted = true\n                mounted && mounted.call(renderContext)\n            }else{\n                beforeUpdate && beforeUpdate.call(renderContext)\n                patch(instance.subTree,subTree as VNode,container,anchor)\n                updated && updated.call(renderContext)\n            }\n            instance.subTree = subTree as VNode\n        }, {scheduler:queueJob})\n    }\n    function hasPropsChanged(prevProps:Record<string,any>,nextProps:Record<string,any>):boolean{\n        const nextKeys = Object.keys(nextProps)\n        if(nextKeys.length !== Object.keys(prevProps).length) return true\n        for(let i = 0;i < nextKeys.length;i++){\n            const key = nextKeys[i]\n            if(prevProps[key] !== nextProps[key]) return true\n        }\n        return false\n    }\n    function patchComponent(n1:VNode,n2:VNode,anchor:VHTMLElement):void{\n        const instance = (n2.component = n1.component)\n        const {props} = instance\n        if(hasPropsChanged(n1.props as Record<string,any>,n2.props as Record<string,any>)){\n            const [nextProps] = resolveProps(n2.type.props as Record<string,any> ,n2.props as Record<string,any>)\n            for(const key in nextProps){\n                props[key] = nextProps[key]\n            }\n            for(const key in props){\n                if(!(key in nextProps)) delete props[key]\n            }\n        }\n    }\n    function patch(n1:VNode | undefined | null,n2:VNode,container:VHTMLElement,anchor?:VHTMLElement):void{\n        if(n1 && n1.type !== n2.type){\n            unmount(n1)\n            n1 = null\n        }\n        const {type} = n2\n        if(typeof type === 'string'){\n            if(!n1){\n                mountElement(n2,container)\n            }else{\n                patchElement(n1,n2)\n            }\n        }else if(typeof type === 'object'){\n            //object代表是组件\n            if(!n1){\n                mountComponent(n2,container,anchor as VHTMLElement)\n            } else{\n                patchComponent(n1,n2,anchor as VHTMLElement)\n            }\n        }else if(type === Text){\n            if(!n1){\n                const el = n2.el =  createText(n2.children as string)\n                insert(el as any,container)\n            }else{\n                // 如果旧 vnode 存在，只需要使用新文本节点的文本内容更新旧文本节点即\n                const el = n2.el = n1.el\n                if(n2.children !== n1.children){\n                    setText(el as VHTMLElement, n2.children as string)\n                }\n            }\n        }\n\n    }\n    function render(vnode:VNode,container:VHTMLElement):void{\n        if(vnode){\n            patch(container._vnode,vnode,container)\n        }else{\n            if(container._vnode){\n                unmount(container._vnode)\n            }\n        }\n        container._vnode = vnode\n    }\n    function unmount(vnode:VNode):void{\n        const parent = vnode.el?.parentNode\n        if(parent){\n            parent.removeChild(vnode.el as Node)\n        }\n    }\n    return {\n        render\n    }\n}\n//写成这样的目的是脱离完全依赖浏览器的掌控，让节点的操作是可人为定义的\nexport const renderer = createRenderer({\n    createElement:(vnode:VNode) => {\n        return document.createElement(vnode.type) as VHTMLElement\n    },\n    insert:(el:HTMLElement,container:HTMLElement) => {\n        container.appendChild(el)   \n    },\n    setElementText:(el:HTMLElement,text:string) => {\n        el.textContent = text\n    },\n    patchProps:(el:HTMLElement,key:string,prevValue:string | null,nextValue:string | null) => {\n        if(/^on/.test(key) && typeof nextValue === 'function'){\n            const invokers = el._vei || (el._vei = {})\n            // 获取为该元素伪造的事件处理函数 invoker\n            let invoker = invokers[key]\n           // 根据属性名称得到对应的事件名称，例如 onClick ---> click\n            const name = key.slice(2).toLowerCase();\n            if(nextValue){\n                if(!invoker){\n                    invoker = el._vei[key]= (e:Event) => {\n                        if (e.timeStamp < invoker.attached) return\n                        if(Array.isArray(invoker.value)){\n                            invoker.value.forEach((fn:Function) => fn(e))\n                        }else{\n                            invoker.value(e)\n                        }\n                    }\n                    invoker.value = nextValue\n                    invoker.attached = performance.now()\n                    el.addEventListener(name,invoker)\n                }else{\n                    invoker.value = nextValue\n                }\n            }else if(invoker){\n                //没有nextValue,但又有invoker，证明是卸载时间\n                el.removeEventListener(name,invoker)\n            }\n        } else if (shouldSetAsProps(el,key)){\n            const type = typeof el[key as keyof HTMLElement];\n            if(type === 'boolean' && nextValue === ''){\n                el[key] = true;\n            }else{\n                el[key] = nextValue;\n            }\n        }else{\n            if (nextValue === null) {\n                el.removeAttribute(key);\n            } else {\n                el.setAttribute(key, nextValue as string);\n            }\n        }\n    },\n    createText(text) {\n        return document.createTextNode(text)\n    },\n    setText(el:VHTMLElement,text:string) {\n        el.nodeValue = text\n    }\n})","import { effect, track, trigger } from \"./effect\"\n\nexport function computed(getter){\n    let value\n    //这个dirty是配合调度器用的\n    let dirty = true\n    const effectFn = effect(getter,{\n        lazy:true,\n        scheduler:()=>{\n            if(!dirty){\n                //调度器执行就证明值有改变然后需要下次get的时候重新调用一下了\n                dirty = true\n                trigger(obj,'value')\n            }\n        }\n    })\n    const obj = {\n        get value(){\n            if(dirty){\n                //执行这个activeEffect函数就已经设为当前的effectFn了\n                //然后其内部再有其他的响应式对象，执行时会嵌套触发新的响应式对象读取，又给他们（内部的所有响应式对象）加上了这个active\n                value = effectFn()\n                dirty = false\n            }\n            //紧接着跟track，就把computed的effectFn收集了\n            track(obj,'value')\n            //实际上是把computed的value返回了\n            return value\n        }\n    }\n    return obj\n}\n","import { reactive } from \"./reactive\"\nexport function ref(value:any){\n    const wrapper = {\n        value:value\n    }\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\n    return reactive(wrapper)\n}\nexport function toRef(obj:Object,key:string){\n    const wrapper = {\n        get value(){\n            return obj[key]\n        },\n        set value(newVal){\n            obj[key] = newVal\n        }\n    }\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\n    return wrapper\n}\nexport function toRefs(obj:Object){\n    const ret = {}\n    for(const key in obj){\n        ret[key] = toRef(obj,key)\n    }\n    return ret\n}\nexport function proxyRefs(target){\n    return new Proxy(target,{\n        get(target,key,receiver){\n            const value = Reflect.get(target,key,receiver)\n            //是ref就用这个来返回.value后的值，不是ref就不返回\n            return value.__v_isRef ? value.value : value\n        }\n    })\n}"],"names":["ITERATE_KEY","Symbol","bucket","WeakMap","activeEffect","effectStack","effect","fn","options","effectFn","i","deps","length","delete","cleanup","push","result","pop","lazy","track","target","key","depsMap","get","set","Map","Set","add","trigger","type","newVal","effectsToRun","iterateEffects","forEach","Array","isArray","lengthEffects","effects","scheduler","traverse","value","seen","has","arrayInstrumentations","createReactive","data","isShallow","isReadonly","Proxy","receiver","hasOwnProperty","Reflect","res","readonly","reactive","console","warn","oldVal","Number","Object","prototype","call","raw","ownKeys","deleteProperty","hadKey","method","originMethod","args","apply","this","reactiveMap","proxyObj","nowObj","shallowReactive","queue","isFlushing","p","Promise","resolve","queueJob","job","then","error","clear","renderer","createElement","insert","setElementText","patchProps","createText","setText","mountElement","vnode","container","el","props","setProps","children","child","patch","patchChildren","n1","n2","unmount","oldChildren","newChildren","oldlen","newlen","commonlen","Math","min","diff","resolveProps","propsData","attrs","patchComponent","anchor","instance","component","prevProps","nextProps","nextKeys","keys","hasPropsChanged","oldProps","newProps","patchElement","componentOptions","setup","render","beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","propsOption","state","isMounted","subTree","setupContext","renderContext","t","k","r","v","mountComponent","Text","parent","_a","parentNode","removeChild","_vnode","createRenderer","document","appendChild","text","textContent","prevValue","nextValue","test","invoker","_vei","name","slice","toLowerCase","e","timeStamp","attached","performance","now","addEventListener","removeEventListener","tagName","shouldSetAsProps","removeAttribute","setAttribute","createTextNode","nodeValue","getter","dirty","obj","wrapper","defineProperty","source","cb","immediate","newValue","oldValue","onInvalidate","log","flush"],"mappings":"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"}