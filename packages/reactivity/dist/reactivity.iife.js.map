{"version":3,"file":"reactivity.iife.js","sources":["../src/effect.ts","../../runtime-core/src/watch.ts","../src/reactive.ts","../../runtime-core/src/renderer.ts","../src/computed.ts","../src/ref.ts"],"sourcesContent":["\nimport type { Dep } from './dep'\n//清除函数\nfunction cleanup(effectFn){\n    for(let i = 0 ; i < effectFn.deps.length;i++){\n        const deps = effectFn.deps[i]\n        deps.delete(effectFn)\n    }\n    effectFn.deps.length = 0;\n}\nexport const ITERATE_KEY = Symbol()\n//这个bucket就是来存副作用函数的\nconst bucket = new WeakMap<any,Map<string,Set<Function>>>();\n//用一个全局变量activeEffect来存储被注册的副作用函数\nlet activeEffect:any\n//这个栈：当发生effect嵌套时，会出现第二个(子effect)把第一个（父effect）的activeEffect给覆盖(因为同时activeEffect的值只有一个)，所以需要一个栈来存储正在执行的副作用函数，副作用函数执行完毕就给弹出\nconst effectStack:Array<any> = []\n// class RectiveEffect<T = any>{\n//     //因为set的时候改变值会触发新的set，所以为了避免死循环，需要一个字段来识别是否执行这个副作用函数,true就是这个副作用函数在执行，false就是没有执行就要触发。\n//     //因为在一开始创建effect的时候肯定是接下来在触发的（这就是业务要求)所以初始为true,接下来执行完就需要手动设置为false\n//     active=true\n//     //这个deps就是用来存放副作用函数的\n//     deps:Dep[] = []\n// }\n//effect函数\nexport function effect(fn:() => any,options:Object = {}){ \n    const effectFn = () => {\n        cleanup(effectFn)\n        activeEffect = effectFn\n        effectStack.push(effectFn)\n        const result = fn()\n        effectStack.pop()\n        //把栈顶函数拿出来给active,就是为了解决嵌套\n        activeEffect = effectStack[effectStack.length - 1]   \n        return result\n    }\n    //源码里的effectFn是一个class类\n    effectFn.deps = []\n    effectFn.options = options\n    if(!options.lazy){\n        effectFn()\n    }\n    return effectFn\n}\n//track ,目的是把当前的activeEffect存储到target和key的依赖集合中\nexport const track = <T>(target:T,key:string |symbol):void => {\n    //这里的判断是，当副作用函数effect已经执行完，接下来系统中某个地方改变了代理值，effect取出重新执行时，依然会触发代理的get（这时候就没有必要再注册一边了）。这个时候是没有active的，所以用这个来让其避免重复注册\n    if(!activeEffect) return\n    let depsMap = bucket.get(target)\n    if(!depsMap) bucket.set(target,(depsMap = new Map()));\n    let deps = depsMap.get(key)\n    if(!deps) depsMap.set(key,(deps = new Set()))\n    deps.add(activeEffect)\n    activeEffect.deps.push(deps)\n}\n//trigger,目的是把当前target和key的依赖集合中的函数取出并执行一遍\nexport const trigger = <T>(target:T,key:string,type:string |symbol,newVal?:any):void => {\n    let depsMap = bucket.get(target)\n    if(!depsMap) return\n    let deps = depsMap.get(key)\n    const effectsToRun = new Set()\n    if(type == 'ADD') {\n        //把跟ITERATE绑定的（forin这种情况）拿出执行\n        const iterateEffects = depsMap.get(ITERATE_KEY)\n        iterateEffects && iterateEffects.forEach(effectFn => {\n            if (effectFn !== activeEffect) {\n                effectsToRun.add(effectFn)\n            }\n        })\n    }   \n    //如果是数组。那么需要额外处理\n    if(type === 'ADD' && Array.isArray(target)){\n        const lengthEffects = depsMap.get('length')\n        lengthEffects && lengthEffects.forEach(effectFn => {\n            if(effectFn !== activeEffect){\n                effectsToRun.add(effectFn)\n            }\n        })\n    }\n    //如果改变length，就需要把大于等于length的值拿出来遍历\n    if(Array.isArray(target) && key === 'length'){\n        depsMap.forEach((effects,key) => {\n           if(key >= newVal){\n            effects.forEach(effectFn => {\n                if(effectFn !== activeEffect){\n                    effectsToRun.add(effectFn)\n                }\n            })\n           }\n        })\n    }\n    deps && deps.forEach(effect => {\n        if(effect != activeEffect) {\n            effectsToRun.add(effect)\n        }\n    })\n    effectsToRun.forEach(effectFn => {\n        if(effectFn.options.scheduler){\n            effectFn.options.scheduler(effectFn)\n        }else{\n            effectFn()\n        }\n    })\n}\n","import { effect } from \"packages/reactivity/index\";\n\nexport function watch(source:any,cb:Function,options:{immediate:boolean,flush?:string} = {immediate:false}){\n    //定义一个getter来接一个函数，如果函数的\n    let getter:Function\n    if(typeof source === 'function'){\n        getter = source\n    }else{\n        getter = () => traverse(source)\n    }\n    //闭包保存此时的新值和旧值\n    let newValue:any = null,oldValue:any = null\n    //定义一个函数寄存外部传来的fn\n    let cleanup:Function\n    function onInvalidate(fn:Function){\n        cleanup = fn\n    }\n    const job = () =>{\n        //执行副作用函数拿到新值   \n        newValue = effectFn()\n        //执行watch传入的函数\n        if(cleanup) cleanup()\n        cb(newValue,oldValue,onInvalidate)\n        //把旧值更新\n        oldValue = newValue\n    }\n    const effectFn = effect(() => getter(),{\n        lazy:true,\n        scheduler:() => {\n            if(options.flush == 'post'){\n                const p = Promise.resolve()\n                p.then(() => job())\n            }else{\n                job()\n            }\n        }\n    })\n    //第一次执行拿到添加响应式依赖\n    if(options.immediate){\n        job()\n    }else{\n        oldValue = effectFn()\n    }\n}\nfunction traverse<T>(value:T,seen:Set<any> = new Set()):T|void{\n    if(typeof value != 'object' || value == null || seen.has(value)) return\n    seen.add(value)\n    for (const key in value as Object) {\n        traverse(value[key as keyof Object],seen)\n    }\n    return value\n}","import { track,trigger ,ITERATE_KEY} from \"./effect\";\n//重写includes,indexof函数，因为原来的这几个函数的this指向是响应式对象\nconst originMethod = Array.prototype.includes\nconst arrayInstrumentations = {}\nconst methods = ['include','indexOf','lastIndexOf']\nmethods.forEach(method => {\n    const originMethod = Array.prototype[method]\n    arrayInstrumentations[method] = function(...args){\n        let res = originMethod.apply(this,args)\n        if(res === false || res === -1){\n            res = originMethod.apply(this.raw,args)\n        }\n        return res\n    }\n})\n//一个标记变量，代表是否进行跟踪。默认为true,代表允许跟踪\nlet shouldTrack:Boolean = true\nlet changeLengthmethods = ['push']\nchangeLengthmethods.forEach(method => {\n    const originMethod = Array.prototype[method]\n})\nexport function createReactive(data:Object,isShallow = false,isReadonly = false){ \n    return new Proxy(data, {\n        get(target, key,receiver) {   \n            if(key === 'raw') return target\n            if(Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) return Reflect.get(arrayInstrumentations,key,receiver)\n            if(!isReadonly && typeof key !== 'symbol') track(target,key)    \n            //Reflect对象，后面的receiver是对象本身，类似this\n            const res =  Reflect.get(target,key,receiver); \n            if(typeof res == 'object' && res!=null && !isShallow){\n                return isReadonly ? readonly(res) : reactive(res)\n            }\n            return res // 返回属性值\n        },\n        set(target, key, newVal,receiver) {\n            //判断是否只读\n            if(isReadonly){\n                console.warn(`属性${key} 是只读的`)\n                return true\n            }\n            //先获取旧值\n            const oldVal = target[key]\n            //属性不存在就添加新属性，否则就是设置已有已有属性\n            const type = Array.isArray(target) ? Number(key) < target.length ? 'SET':'ADD'  : Object.prototype.hasOwnProperty.call(target,key) ? 'SET':'ADD'\n            //设置属性值\n            const res = Reflect.set(target, key, newVal, receiver)  // 设置新值\n            // 触发所有副作用函数\n            if(target === receiver.raw){\n                if(oldVal != newVal && (oldVal === oldVal || newVal === newVal)) trigger(target,key,type,newVal)\n            }\n            return true;\n        },\n        //has来对in操作符来拦截\n        has(target,key){\n            track(target,key)\n            return Reflect.get(target,key);\n        },\n        //拦截forin\n        ownKeys(target) {\n            // 将副作用函数与 ITERATE_KEY 关联,拦截for...in\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\n            return Reflect.ownKeys(target)\n        },\n        //拦截删除\n        deleteProperty(target,key){\n            if(isReadonly){\n                console.warn(`属性${key} 是只读的`)\n                return true\n            }\n            const hadKey = Object.prototype.hasOwnProperty.call(target,key)\n            const res = Reflect.deleteProperty(target, key)\n            if (res && hadKey) {\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\n                trigger(target, key, 'DELETE')\n            }\n            return res\n        }\n    });\n}\n//这个值用来记录Obj是否已经创建过代理对象\nconst reactiveMap = new Map()\n//建立深响应\nexport function reactive(data:Object){\n    //如果传入的对象曾经创建过响应式对象，就把曾经创建的对象返回出去\n    const proxyObj = reactiveMap.get(data)\n    if(proxyObj) return proxyObj\n    const nowObj = createReactive(data)\n    //存起来避免重复创建\n    reactiveMap.set(data,nowObj)\n    return nowObj\n}\n//建立浅响应\nexport function shallowReactive(data:Object){\n    return createReactive(data,true)\n}\nexport function readonly(data:Object){\n    return createReactive(data,false,true)\n}\nexport function shallowReadonly(data:Object){\n    return createReactive(data,true,true)\n}","interface Options {\n    createElement: (vnode:VNode) => HTMLElement\n    insert:(el:HTMLElement,parents:HTMLElement) => void\n    setElementText:(el:HTMLElement,text:string) => void\n    patchProps:(el:HTMLElement,key:string,prevValue:string,nextValue:string) => void \n}\ninterface Render {\n    render: (vnode:VNode,container:VHTMLElement) => void\n}\nfunction shouldSetAsProps(el:HTMLElement,key:string):Boolean{\n    return key === 'form' && el.tagName === 'INPUT' ? false : key in el\n}\nexport function createRenderer(options:Options):Render{\n    const {createElement,insert,setElementText,patchProps} = options\n    //设置props\n    function setProps(el:HTMLElement,vnode:VNode):void{\n        if(vnode.props) {\n            for(const key in vnode.props){\n                patchProps(el,key,null,vnode.props[key])\n            }\n        }\n    }   \n    function mountElement(vnode:VNode,container:VHTMLElement):void{\n        const el = createElement(vnode)\n        setProps(el,vnode)\n        //处理子类节点\n        if(typeof vnode.children =='string'){\n            setElementText(el,vnode.children)\n        }else if(Array.isArray(vnode.children)){\n            vnode.children.forEach(child => patch(null,child,el as VHTMLElement))\n        }\n        insert(el, container)\n    }\n    function patch(n1:VNode | undefined | null,n2:VNode,container:VHTMLElement):void{\n        if(!n1){\n            mountElement(n2,container)\n        }else{\n\n        }\n\n    }\n    function render(vnode:VNode,container:VHTMLElement):void{\n        if(vnode){\n            patch(container._vnode,vnode,container)\n        }else{\n            if(container._vnode){\n                //卸载载旧节点\n                container.innerHTML = ''\n            }\n        }\n        container._vnode = vnode\n    }\n    return {\n        render\n    }\n}\n//写成这样的目的是脱离完全依赖浏览器的掌控，让节点的操作是可人为定义的\nexport const renderer = createRenderer({\n    createElement:(vnode:VNode) => {\n        return document.createElement(vnode.type)\n    },\n    insert:(el:HTMLElement,container:HTMLElement) => {\n        container.appendChild(el)   \n    },\n    setElementText:(el:HTMLElement,text:string) => {\n        el.textContent = text\n    },\n    patchProps:(el:HTMLElement,key:string,prevValue:string | null,nextValue:string | null) => {\n        if(shouldSetAsProps(el,key)){\n            const type = typeof el[key as keyof HTMLElement]\n            if(type === 'boolean' && nextValue === ''){\n                el[key] = true\n            }else{\n                el[key] = nextValue\n            }\n        }else{\n            el.setAttribute(key,nextValue as string)\n        }\n    }\n})","import { effect, track, trigger } from \"./effect\"\n\nexport function computed(getter){\n    let value\n    //这个dirty是配合调度器用的\n    let dirty = true\n    const effectFn = effect(getter,{\n        lazy:true,\n        scheduler:()=>{\n            if(!dirty){\n                //调度器执行就证明值有改变然后需要下次get的时候重新调用一下了\n                dirty = true\n                trigger(obj,'value')\n            }\n        }\n    })\n    const obj = {\n        get value(){\n            if(dirty){\n                //执行这个activeEffect函数就已经设为当前的effectFn了\n                //然后其内部再有其他的响应式对象，执行时会嵌套触发新的响应式对象读取，又给他们（内部的所有响应式对象）加上了这个active\n                value = effectFn()\n                dirty = false\n            }\n            //紧接着跟track，就把computed的effectFn收集了\n            track(obj,'value')\n            //实际上是把computed的value返回了\n            return value\n        }\n    }\n    return obj\n}\n","import { reactive } from \"./reactive\"\nexport function ref(value:any){\n    const wrapper = {\n        value:value\n    }\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\n    return reactive(wrapper)\n}\nexport function toRef(obj:Object,key:string){\n    const wrapper = {\n        get value(){\n            return obj[key]\n        },\n        set value(newVal){\n            obj[key] = newVal\n        }\n    }\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\n    return wrapper\n}\nexport function toRefs(obj:Object){\n    const ret = {}\n    for(const key in obj){\n        ret[key] = toRef(obj,key)\n    }\n    return ret\n}\nexport function proxyRefs(target){\n    return new Proxy(target,{\n        get(target,key,receiver){\n            const value = Reflect.get(target,key,receiver)\n            //是ref就用这个来返回.value后的值，不是ref就不返回\n            return value.__v_isRef ? value.value : value\n        }\n    })\n}"],"names":["ITERATE_KEY","Symbol","bucket","WeakMap","activeEffect","effectStack","effect","fn","options","effectFn","i","deps","length","delete","cleanup","push","result","pop","lazy","track","target","key","depsMap","get","set","Map","Set","add","trigger","type","newVal","effectsToRun","iterateEffects","forEach","Array","isArray","lengthEffects","effects","scheduler","traverse","value","seen","has","arrayInstrumentations","createReactive","data","isShallow","isReadonly","Proxy","receiver","hasOwnProperty","Reflect","res","readonly","reactive","console","warn","oldVal","Number","Object","prototype","call","raw","ownKeys","deleteProperty","hadKey","method","originMethod","args","apply","this","reactiveMap","proxyObj","nowObj","renderer","createElement","insert","setElementText","patchProps","mountElement","vnode","container","el","props","setProps","children","child","patch","n1","n2","render","_vnode","innerHTML","createRenderer","document","appendChild","text","textContent","prevValue","nextValue","tagName","shouldSetAsProps","setAttribute","getter","dirty","obj","wrapper","defineProperty","source","cb","immediate","newValue","oldValue","onInvalidate","job","flush","Promise","resolve","then"],"mappings":"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"}