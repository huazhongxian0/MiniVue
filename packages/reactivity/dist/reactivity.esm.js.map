{"version":3,"file":"reactivity.esm.js","sources":["../src/effect.ts","../src/computed.ts","../../runtime-core/src/watch.ts","../src/reactive.ts","../src/ref.ts","../../runtime-core/src/renderer.ts"],"sourcesContent":["\r\nimport type { Dep } from './dep'\r\n//清除函数\r\nfunction cleanup(effectFn){\r\n    for(let i = 0 ; i < effectFn.deps.length;i++){\r\n        const deps = effectFn.deps[i]\r\n        deps.delete(effectFn)\r\n    }\r\n    effectFn.deps.length = 0;\r\n}\r\nexport const ITERATE_KEY = Symbol()\r\n//这个bucket就是来存副作用函数的\r\nconst bucket = new WeakMap<any,Map<string,Set<Function>>>();\r\n//用一个全局变量activeEffect来存储被注册的副作用函数\r\nlet activeEffect:any\r\n//这个栈：当发生effect嵌套时，会出现第二个(子effect)把第一个（父effect）的activeEffect给覆盖(因为同时activeEffect的值只有一个)，所以需要一个栈来存储正在执行的副作用函数，副作用函数执行完毕就给弹出\r\nconst effectStack:Array<any> = []\r\n// class RectiveEffect<T = any>{\r\n//     //因为set的时候改变值会触发新的set，所以为了避免死循环，需要一个字段来识别是否执行这个副作用函数,true就是这个副作用函数在执行，false就是没有执行就要触发。\r\n//     //因为在一开始创建effect的时候肯定是接下来在触发的（这就是业务要求)所以初始为true,接下来执行完就需要手动设置为false\r\n//     active=true\r\n//     //这个deps就是用来存放副作用函数的\r\n//     deps:Dep[] = []\r\n// }\r\n//effect函数\r\nexport function effect(fn:() => any,options:Object = {}){ \r\n    const effectFn = () => {\r\n        cleanup(effectFn)\r\n        activeEffect = effectFn\r\n        effectStack.push(effectFn)\r\n        const result = fn()\r\n        effectStack.pop()\r\n        //把栈顶函数拿出来给active,就是为了解决嵌套\r\n        activeEffect = effectStack[effectStack.length - 1]   \r\n        return result\r\n    }\r\n    //源码里的effectFn是一个class类\r\n    effectFn.deps = []\r\n    effectFn.options = options\r\n    if(!options.lazy){\r\n        effectFn()\r\n    }\r\n    return effectFn\r\n}\r\n//track ,目的是把当前的activeEffect存储到target和key的依赖集合中\r\nexport const track = <T>(target:T,key:string |symbol):void => {\r\n    //这里的判断是，当副作用函数effect已经执行完，接下来系统中某个地方改变了代理值，effect取出重新执行时，依然会触发代理的get（这时候就没有必要再注册一边了）。这个时候是没有active的，所以用这个来让其避免重复注册\r\n    if(!activeEffect) return\r\n    let depsMap = bucket.get(target)\r\n    if(!depsMap) bucket.set(target,(depsMap = new Map()));\r\n    let deps = depsMap.get(key)\r\n    if(!deps) depsMap.set(key,(deps = new Set()))\r\n    deps.add(activeEffect)\r\n    activeEffect.deps.push(deps)\r\n}\r\n//trigger,目的是把当前target和key的依赖集合中的函数取出并执行一遍\r\nexport const trigger = <T>(target:T,key:string,type:string |symbol,newVal?:any):void => {\r\n    let depsMap = bucket.get(target)\r\n    if(!depsMap) return\r\n    let deps = depsMap.get(key)\r\n    const effectsToRun = new Set()\r\n    if(type == 'ADD') {\r\n        //把跟ITERATE绑定的（forin这种情况）拿出执行\r\n        const iterateEffects = depsMap.get(ITERATE_KEY)\r\n        iterateEffects && iterateEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }   \r\n    //如果是数组。那么需要额外处理\r\n    if(type === 'ADD' && Array.isArray(target)){\r\n        const lengthEffects = depsMap.get('length')\r\n        lengthEffects && lengthEffects.forEach(effectFn => {\r\n            if(effectFn !== activeEffect){\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n    //如果改变length，就需要把大于等于length的值拿出来遍历\r\n    if(Array.isArray(target) && key === 'length'){\r\n        depsMap.forEach((effects,key) => {\r\n           if(key >= newVal){\r\n            effects.forEach(effectFn => {\r\n                if(effectFn !== activeEffect){\r\n                    effectsToRun.add(effectFn)\r\n                }\r\n            })\r\n           }\r\n        })\r\n    }\r\n    deps && deps.forEach(effect => {\r\n        if(effect != activeEffect) {\r\n            effectsToRun.add(effect)\r\n        }\r\n    })\r\n    effectsToRun.forEach(effectFn => {\r\n        if(effectFn.options.scheduler){\r\n            effectFn.options.scheduler(effectFn)\r\n        }else{\r\n            effectFn()\r\n        }\r\n    })\r\n}\r\n","import { effect, track, trigger } from \"./effect\"\r\n\r\nexport function computed(getter){\r\n    let value\r\n    //这个dirty是配合调度器用的\r\n    let dirty = true\r\n    const effectFn = effect(getter,{\r\n        lazy:true,\r\n        scheduler:()=>{\r\n            if(!dirty){\r\n                //调度器执行就证明值有改变然后需要下次get的时候重新调用一下了\r\n                dirty = true\r\n                trigger(obj,'value')\r\n            }\r\n        }\r\n    })\r\n    const obj = {\r\n        get value(){\r\n            if(dirty){\r\n                //执行这个activeEffect函数就已经设为当前的effectFn了\r\n                //然后其内部再有其他的响应式对象，执行时会嵌套触发新的响应式对象读取，又给他们（内部的所有响应式对象）加上了这个active\r\n                value = effectFn()\r\n                dirty = false\r\n            }\r\n            //紧接着跟track，就把computed的effectFn收集了\r\n            track(obj,'value')\r\n            //实际上是把computed的value返回了\r\n            return value\r\n        }\r\n    }\r\n    return obj\r\n}\r\n","import { effect } from \"packages/reactivity/index\";\r\n\r\nexport function watch(source:any,cb:Function,options:{immediate:boolean,flush?:string} = {immediate:false}){\r\n    //定义一个getter来接一个函数，如果函数的\r\n    let getter:Function\r\n    if(typeof source === 'function'){\r\n        getter = source\r\n    }else{\r\n        getter = () => traverse(source)\r\n    }\r\n    //闭包保存此时的新值和旧值\r\n    let newValue:any = null,oldValue:any = null\r\n    //定义一个函数寄存外部传来的fn\r\n    let cleanup:Function\r\n    function onInvalidate(fn:Function){\r\n        cleanup = fn\r\n    }\r\n    const job = () =>{\r\n        //执行副作用函数拿到新值   \r\n        newValue = effectFn()\r\n        //执行watch传入的函数\r\n        if(cleanup) cleanup()\r\n        cb(newValue,oldValue,onInvalidate)\r\n        //把旧值更新\r\n        oldValue = newValue\r\n    }\r\n    const effectFn = effect(() => getter(),{\r\n        lazy:true,\r\n        scheduler:() => {\r\n            if(options.flush == 'post'){\r\n                const p = Promise.resolve()\r\n                p.then(() => job())\r\n            }else{\r\n                job()\r\n            }\r\n        }\r\n    })\r\n    //第一次执行拿到添加响应式依赖\r\n    if(options.immediate){\r\n        job()\r\n    }else{\r\n        oldValue = effectFn()\r\n    }\r\n}\r\nfunction traverse<T>(value:T,seen:Set<any> = new Set()):T|void{\r\n    if(typeof value != 'object' || value == null || seen.has(value)) return\r\n    seen.add(value)\r\n    for (const key in value as Object) {\r\n        traverse(value[key as keyof Object],seen)\r\n    }\r\n    return value\r\n}","import { track,trigger ,ITERATE_KEY} from \"./effect\";\r\n//重写includes,indexof函数，因为原来的这几个函数的this指向是响应式对象\r\nconst originMethod = Array.prototype.includes\r\nconst arrayInstrumentations = {}\r\nconst methods = ['include','indexOf','lastIndexOf']\r\nmethods.forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n    arrayInstrumentations[method] = function(...args){\r\n        let res = originMethod.apply(this,args)\r\n        if(res === false || res === -1){\r\n            res = originMethod.apply(this.raw,args)\r\n        }\r\n        return res\r\n    }\r\n})\r\n//一个标记变量，代表是否进行跟踪。默认为true,代表允许跟踪\r\nlet shouldTrack:Boolean = true\r\nlet changeLengthmethods = ['push']\r\nchangeLengthmethods.forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n})\r\nexport function createReactive(data:Object,isShallow = false,isReadonly = false){ \r\n    return new Proxy(data, {\r\n        get(target, key,receiver) {   \r\n            if(key === 'raw') return target\r\n            if(Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) return Reflect.get(arrayInstrumentations,key,receiver)\r\n            if(!isReadonly && typeof key !== 'symbol') track(target,key)    \r\n            //Reflect对象，后面的receiver是对象本身，类似this\r\n            const res =  Reflect.get(target,key,receiver); \r\n            if(typeof res == 'object' && res!=null && !isShallow){\r\n                return isReadonly ? readonly(res) : reactive(res)\r\n            }\r\n            return res // 返回属性值\r\n        },\r\n        set(target, key, newVal,receiver) {\r\n            //判断是否只读\r\n            if(isReadonly){\r\n                console.warn(`属性${key} 是只读的`)\r\n                return true\r\n            }\r\n            //先获取旧值\r\n            const oldVal = target[key]\r\n            //属性不存在就添加新属性，否则就是设置已有已有属性\r\n            const type = Array.isArray(target) ? Number(key) < target.length ? 'SET':'ADD'  : Object.prototype.hasOwnProperty.call(target,key) ? 'SET':'ADD'\r\n            //设置属性值\r\n            const res = Reflect.set(target, key, newVal, receiver)  // 设置新值\r\n            // 触发所有副作用函数\r\n            if(target === receiver.raw){\r\n                if(oldVal != newVal && (oldVal === oldVal || newVal === newVal)) trigger(target,key,type,newVal)\r\n            }\r\n            return true;\r\n        },\r\n        //has来对in操作符来拦截\r\n        has(target,key){\r\n            track(target,key)\r\n            return Reflect.get(target,key);\r\n        },\r\n        //拦截forin\r\n        ownKeys(target) {\r\n            // 将副作用函数与 ITERATE_KEY 关联,拦截for...in\r\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\r\n            return Reflect.ownKeys(target)\r\n        },\r\n        //拦截删除\r\n        deleteProperty(target,key){\r\n            if(isReadonly){\r\n                console.warn(`属性${key} 是只读的`)\r\n                return true\r\n            }\r\n            const hadKey = Object.prototype.hasOwnProperty.call(target,key)\r\n            const res = Reflect.deleteProperty(target, key)\r\n            if (res && hadKey) {\r\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\r\n                trigger(target, key, 'DELETE')\r\n            }\r\n            return res\r\n        }\r\n    });\r\n}\r\n//这个值用来记录Obj是否已经创建过代理对象\r\nconst reactiveMap = new Map()\r\n//建立深响应\r\nexport function reactive(data:Object){\r\n    //如果传入的对象曾经创建过响应式对象，就把曾经创建的对象返回出去\r\n    const proxyObj = reactiveMap.get(data)\r\n    if(proxyObj) return proxyObj\r\n    const nowObj = createReactive(data)\r\n    //存起来避免重复创建\r\n    reactiveMap.set(data,nowObj)\r\n    return nowObj\r\n}\r\n//建立浅响应\r\nexport function shallowReactive(data:Object){\r\n    return createReactive(data,true)\r\n}\r\nexport function readonly(data:Object){\r\n    return createReactive(data,false,true)\r\n}\r\nexport function shallowReadonly(data:Object){\r\n    return createReactive(data,true,true)\r\n}","import { reactive } from \"./reactive\"\r\nexport function ref(value:any){\r\n    const wrapper = {\r\n        value:value\r\n    }\r\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\r\n    return reactive(wrapper)\r\n}\r\nexport function toRef(obj:Object,key:string){\r\n    const wrapper = {\r\n        get value(){\r\n            return obj[key]\r\n        },\r\n        set value(newVal){\r\n            obj[key] = newVal\r\n        }\r\n    }\r\n    Object.defineProperty(wrapper,'__v_isRef',{value:true})\r\n    return wrapper\r\n}\r\nexport function toRefs(obj:Object){\r\n    const ret = {}\r\n    for(const key in obj){\r\n        ret[key] = toRef(obj,key)\r\n    }\r\n    return ret\r\n}\r\nexport function proxyRefs(target){\r\n    return new Proxy(target,{\r\n        get(target,key,receiver){\r\n            const value = Reflect.get(target,key,receiver)\r\n            //是ref就用这个来返回.value后的值，不是ref就不返回\r\n            return value.__v_isRef ? value.value : value\r\n        }\r\n    })\r\n}","export function renderer(DomString:string,dom:HTMLElement){\r\n    dom.innerHTML = DomString\r\n}"],"names":["ITERATE_KEY","Symbol","bucket","WeakMap","activeEffect","effectStack","effect","fn","options","effectFn","i","deps","length","delete","cleanup","push","result","pop","lazy","track","target","key","depsMap","get","set","Map","Set","add","trigger","type","newVal","effectsToRun","iterateEffects","forEach","Array","isArray","lengthEffects","effects","scheduler","computed","getter","value","dirty","obj","watch","source","cb","immediate","traverse","newValue","oldValue","onInvalidate","job","flush","Promise","resolve","then","seen","has","arrayInstrumentations","createReactive","data","isShallow","isReadonly","Proxy","receiver","hasOwnProperty","Reflect","res","readonly","reactive","console","warn","oldVal","Number","Object","prototype","call","raw","ownKeys","deleteProperty","hadKey","method","originMethod","args","apply","this","reactiveMap","proxyObj","nowObj","shallowReactive","shallowReadonly","ref","wrapper","defineProperty","renderer","DomString","dom","innerHTML"],"mappings":"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"}